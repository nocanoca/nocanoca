<html>
<head>
	<script type='text/javascript'>
		
				 var NS = "http://www.w3.org/2000/svg";
	 //GUI FUNCTIONALITY
	 var elem = document.documentElement;

	 /* View in fullscreen */
	 function openFullscreen() {
	   if (elem.requestFullscreen) {
	     elem.requestFullscreen();
	   } else if (elem.mozRequestFullScreen) { /* Firefox */
	     elem.mozRequestFullScreen();
	   } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
	     elem.webkitRequestFullscreen();
	   } else if (elem.msRequestFullscreen) { /* IE/Edge */
	     elem.msRequestFullscreen();
	   }
	 }
	 
	 function closeFullscreen() {
	   if (document.exitFullscreen) {
	     document.exitFullscreen();
	   } else if (document.mozCancelFullScreen) { /* Firefox */
	     document.mozCancelFullScreen();
	   } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
	     document.webkitExitFullscreen();
	   } else if (document.msExitFullscreen) { /* IE/Edge */
	     document.msExitFullscreen();
	   }
	 }
	 
	 //GLOBAL SETTINGS
	 var showpolylines = false;
	 var showsmootharcs = true; 
	 var showorientations = false;
	 var showtrapeziums = false;
	 var labelvertices = false;
	 
	 //element function binding

	 class UserPath{
	   constructor(pathname, vertices, isclosed, svgelement) {
	     this.name = pathname;
	     this.vertices = vertices;
		 this.isclosed = isclosed;
		 this.svgelement = svgelement;
	 }
	    //builds a polyline from user input.
	 	// note that we force an assumption of 'genericity' here, by ensuring that all vertices have distinct x-coordinates.
	 // this greatly simplifies sweep-line algorithms - if it becomes a problem then it can be changed.
	     toPolyline() {
			 const vertskip = 10;
			 const vertdist = 20;
			 var polyvertices = [this.vertices[0]];
			 for (var i = vertskip; i<this.vertices.length; i = i+vertskip){
				 
				 
				 //checks vertices arent too close
				 if (dist(this.vertices[i], this.vertices[i-vertskip])>vertdist){
					 
 					//check for genericity
 					if (polyvertices.some(e => e[1] === this.vertices[i][1])) { 
 						console.log("BE CAREFUL THIS ISNT A GENERIC POLYGON.")
						console.log(this.vertices[i]);
 					}
					polyvertices.push(this.vertices[i]);
					
					
				 }

			 }
			 
			 //make sure we hit the final vertex if it's not a closed curve.
			 if (!this.isclosed){
			 	polyvertices.push(this.vertices[this.vertices.length-1]);
		 	}
			 

			 
			 return new Polyline(this.name, polyvertices, this.isclosed);
	     }
		 
		 draw(){
			 document.getElementById("page").appendChild(this.svgelement);
		 }
		 undraw(){
			 document.getElementById("page").removeChild(this.svgelement);
		 }
	   
	 }
	 
	 //POLYLINE
	 //this is a bunch of vertices, at its most basic.
	 //can store an svg element, which is an object in the DOM that represents it as an svg path.
	 //also can store a smoothing, which is a smooth curve computed by smoothing the corners via bezier curves.
	 // also stores orientation. this is important (and potentially confusing).
	 // the vertices are always generated by the user curve constructor so that the curve is anti-clockwise.
	 // but before we store these, the user curve constructor also determines whether the curve was drawn clockwise or anticlockwise and stores this in the polyline data too.
	 //i.e. vertices are stored anticlock order, and orientation tells you whether to traverse them in order for an anticlockwise cuve(+1) or in reverse for a clockwise one.
	class Polyline{
		constructor(polygonname, vertices, isclosed) {
			this.name = polygonname;
			this.vertices = vertices;
			this.isclosed = isclosed;
			this.svgelement = undefined;
			this.smoothing = undefined;
			this.orientation = undefined;
			this.trapeziumdecomposition = undefined;
		}

		makeSVGPolyline(){
			var page = document.getElementById("page");
			var thepath = document.createElementNS(NS, "path");

			//number of nodes.
			var numbernodes = this.vertices.length;

			thepath.setAttribute("class", "alphaArc");

			//makes a correct 'd' string out of the nodeslist for passing to the path. start by initialising start point.
			var datastring = "M "+coordString(this.vertices[0]);

			//now if i have any more nodes, i can just add them on the end with T inbetween. T says to use the same control point as the first one, to make life easier.
			if (numbernodes > 2){
				for (var i = 1; i < numbernodes; i++) {
					datastring += (' L '+ coordString(this.vertices[i]));
			 	}
			}

			//if it's closed then Z says to close it up in the drawing without adding more vertices.
			if (this.isclosed){
				datastring += ' Z ';
			}


			thepath.setAttribute("d", datastring);
			
			this.svgelement = thepath;
			
		}
		
		draw(){
			if (!(this.svgelement)){
				this.makeSVGPolyline();
			}
			var page = document.getElementById("page");
			page.appendChild(this.svgelement);
		}
		
		hide(){
			var page = document.getElementById("page");
			page.removeChild(this.svgelement);
		}
	   
		makeSmoothing(){
			const smoothing = 0.4;
			
			//scales vector ab by lambda, treating a as origin. returns scaling of b.
			function scaleSegment(a, b, lambda){
				var vector = [b[0]-a[0], b[1]-a[1]];
				vector = [lambda*vector[0], lambda*vector[1]];
				return [a[0]+vector[0], a[1]+vector[1]];
			}
			

			//smoothing a chain/polyline by clipping off corners. smoothing controls how close to the corner we clip.
			function chainSmooth(chain, currentclosed){
				
				
				
				//can't clip too much or all hell breaks loose!
				if (smoothing > 0.5){
					smoothing = 0.5;
				}

				var newchain = []
				var novertices = chain.length;

				//start with the first vertex. case depends on if we're closed or not.
				if (currentclosed){
					newchain.push(scaleSegment(chain[0], chain[1], smoothing));
				}
				else{
					newchain.push(chain[0]);
				}
				
				for (var i = 1; i < novertices-1; i++) {
					newchain.push(scaleSegment(chain[i], chain[i-1], smoothing));
					newchain.push(scaleSegment(chain[i], chain[i+1], smoothing));
				}
				
				//end with the last vertex.
				
				if (currentclosed){
					newchain.push(scaleSegment(chain[0], chain[novertices-1], smoothing));
				}
				else{
					newchain.push(chain[novertices-1]);
				}

				//closes chain up again
				//newchain.push(scaleSegment(chain[0], chain[novertices-2], smoothing));
				
				return newchain;
			}
			
			var keynodeslist = this.vertices;
			var nodeslist = chainSmooth(this.vertices, this.isclosed);

			var page = document.getElementById("page");
			var thepath = document.createElementNS(NS, "path");

			//number of keynodes. is equal to half the number of nodes.
			var numberkeynodes = keynodeslist.length;

			thepath.setAttribute("class", "alphaArc");

		//makes a correct 'd' string out of the nodeslist for passing to the path. start by initialising start point and first truncated vertex.
		var datastring = "M "+coordString(nodeslist[0]) + 'T' + coordString(nodeslist[1]);

		//now we populate the rest. the point is that we essentially use the initial 'corners' of the polygon as the key nodes, and for nodes we take the vertices of the clipped polygon. the syntax is that the first thing after Q is the keynode, then the next thing is the subsequent vertex. the 'T' says to draw a straight line to the next vertex (corresponding to a genuine edge of the original polygon) and then we repeat the loop, drawing the curved corner and the next edge.
		if (numberkeynodes > 1){
				for (var i = 1; i < numberkeynodes-1; i++) {
					datastring += ' Q '+ coordString(keynodeslist[i]) + ' '+ coordString(nodeslist[2*i]) + ' T ' + coordString(nodeslist[2*i+1]);
			 	}
		}
		
		//if it's closed we need to smooth over the 'start' (=end) vertex.
		if (this.isclosed){
			datastring += 'Q' + coordString(keynodeslist[0]) + ' '+ coordString(nodeslist[0]);
		}
		
			
		thepath.setAttribute("d", datastring);
		
		this.smoothing = thepath;

			

		}
		
		drawSmooth(){
			if (!(this.smoothing)){
				this.makeSmoothing();
			}
			var page = document.getElementById("page");
			page.appendChild(this.smoothing);
		}
	
		hideSmooth(){
			var page = document.getElementById("page");
			page.removeChild(this.smoothing);
		}
		
		
		//returns the arc between the two points specified.
		arcBetween(p,q){
			return [q[0]-p[0], q[1]-p[1]];
		}
		
		//determines the orientation of the triangle abc.
		//returns -1 or +1, where +1 is anticlockwise.
		localOrientation(a, b, c){
			var arc1 = this.arcBetween(a, b);
			var arc2 = this.arcBetween(b, c);
			//embed into R^3
			arc1.push(0);
			arc2.push(0);
			//cross product detects whether or not the orientation is positive or negative, when you view as living in the xy-plane in R^3.
			return -Math.sign(crossProduct(arc1, arc2)[2]);
		}
		
		//returns -1 or +1. +1 is anticlockwise, -1 is clockwise.
		findOrientation(){
			//find  globalmaximum. picks rightmost if tie. uses spread syntax.
			//not sure if need to pick rightmost.
			var ys = this.vertices.map(function(vertex) {
    return vertex[1];
});

			var maxheight = Math.max(...ys);
			var maximums = this.vertices.filter(vertex => vertex[1] == maxheight);
			var xs = maximums.map(function(vertex) {
    return vertex[0];
	});
			var maxright = Math.max(...xs);
            var maxima = maximums.filter(vertex => vertex[0] == maxright)[0];			
			var indexmaxima = this.vertices.indexOf(maxima);

			//handles edge cases.
			if (indexmaxima == 0){
				var before = this.vertices[this.vertices.length - 2];
				var after = this.vertices[1];
			}
			else if (indexmaxima == this.vertices.length - 1){
				var before = this.vertices[this.vertices.length - 2];
				var after = this.vertices[1];
			}
			//otherwise get the prev and next points
			else {

				var before = this.vertices[indexmaxima-1];
				var after = this.vertices[indexmaxima+1];
			}
			var arc1 = this.arcBetween(before, maxima);
			var arc2 = this.arcBetween(maxima, after);
			return this.localOrientation(before, maxima, after);
			
		}
		
		labelStart(thelabel){
			drawLabel(this.vertices[0], thelabel);
		}
		
		showOrientation(){
			if (!this.orientation){
				this.orientation = this.findOrientation();
			}
			this.labelStart('Orientation'+this.orientation);
		}
		
		labelVertices(){
			for (var i=0; i < this.vertices.length; i++){
				drawLabel(this.vertices[i], "("+coordString(this.vertices[i])+")");
			}
		}
		
		//ordering function for vertices. returns +1 if p.y > q.y, -1 if p.y < q.y, or, if they are the same y coord, returns +1 if p.x > q.x and -1 if p.x < q.x. returns 0 if the same point.
		flowingDownLeft(p, q){
			if (p[1] != q[1]){
				return (p[1] > q[1]);
			}
			else {
				return (p[0] > q[0]);
			}
		}
		
		//gets all the edges. orients them so that they flow downwards, i.e. so that the y-coord of the second point is lower.
		//if there is a tie, orient so they flow right-left, i.e. so that the x-coord of second point is lower.
		getEdgeList(){
			var edges = []
			
			

			for (var i = 0; i<this.vertices.length-1; i++){
				var vert = this.vertices[i];
				var nextvert = this.vertices[i+1]
				
				if (this.flowingDownLeft(vert, nextvert)){
					edges.push([vert, nextvert]);
				}
				else {
					edges.push([nextvert, vert]);
				}
				
			}
			//if it's closed then push the closing up edge too.
			if (this.isclosed){
				var vert = this.vertices[0];
				var nextvert = this.vertices[this.vertices.length-1];
				
				if (this.flowingDownLeft(vert, nextvert)){
					edges.push([vert, nextvert]);
				}
				else {
					edges.push([nextvert, vert]);
				}
				
			}
			console.log(edges);
			return edges;	
		}
		
		//finds an upper bound on the x-coordinate of the vertices of a polygon.
		rightBound(){
			var bound = Math.max.apply(Math, this.vertices.map(function(o) { return o[0]; }));
			return bound;
			}

//SUPPOSED TO FIND TRAP DECOMPOSITION.
			//CURRENTLY BREAKS BADLY FOR ANYTHING NON-GENERIC
			//probably also breaks for other special, bad cases.
			//dealing with horizontal segments seems, in general, quite badly behaved.
			//giving up here and going on to breaking into monotone sections, with the hope that this could simplify the algorithm here a lot.

		findTrapeziumDecomposition(){
			var polygon = this;
			if (!this.isclosed){
				return undefined;
			}
			//returns birth if edge flows out of root
			//returns death if edge flows into root
			//returns ephemeral otherwise.
			//assumes that edge flows downwards already.
			function isBirthDeathEphemeral(edge, root){
				if (edge[0][1] == edge[1][1]){
	//				console.log('ephem');
					return 'ephemeral';
				}
				//this is clunky. for some reason it wasn't comparing correctly sometimes to decide
				else if (edge[0][0] == root[0] && edge[0][1] == root[1]){
	//				console.log('birth');
					return 'birth';
				}
				else if (edge[1][0] == root[0] && edge[1][1] == root[1]){
	//				console.log('death');
					return 'death';
				}
				else {
					console.log('ERROR: cant decide in isBirthDeathEphemeral')
				}
			}
			
			//gets all the information for resolving at a given vertex.
			//returns list of elements of form
			// [vertex, sweepdirections, birthedges, deathedges, ephemeraledges]
			// edges are oriented by descending y-coordinate.
			function getVertexResolutionData(polygon){

				var vertices = polygon.vertices;
				
				var novertices = vertices.length;
				var globalorientation = 1;
			
				var resolutiondata = [];
			
				//gets edges so that we can store the same references to them throughout - otherwise removal is hard later.
				//recall they are oriented to flow down.
				var edges = polygon.getEdgeList();
			//	console.log(vertices);
			//	console.log(edges);
			
				//let's go by vertex.
				for (var i = 0; i<novertices; i++){				
					var birthedges = []
					var deathedges = []
					var ephemeraledges = []
				
					var vertex = vertices[i];
					if (i == 0){
						var priorvertex = vertices[novertices-1];
						var prioredge = edges[novertices-1];						
					}
					else {
						var priorvertex = vertices[i-1];
						var prioredge = edges[i-1]
					}
					if (i == novertices-1){
						var followvertex = vertices[0];
						var followedge = edges[i];
					}
					else {
						var followvertex = vertices[i+1];
						var followedge = edges[i];
					}
					

					//sort the adjacent edges into categories.
					switch (isBirthDeathEphemeral(prioredge, vertex)){
					case 'ephemeral':
						console.log('vertex' +vertex +'is eph')

						ephemeraledges.push(prioredge);
						break;
					case 'birth':
						birthedges.push(prioredge);
						break;
					case 'death':
						deathedges.push(prioredge);
						break;
					}

					
					switch (isBirthDeathEphemeral(followedge, vertex)){
					case 'ephemeral':
						console.log('vertex' +vertex +'is eph second')
						
						ephemeraledges.push(followedge);
						break;
					case 'birth':
						birthedges.push(followedge);
						break;
					case 'death':
						deathedges.push(followedge);
						break;
					}
				
					//end of sorting
					
					var vertexnature = 'unsure';
				
					//determines nature of the vertex from this information.
					//no x-parallel edges.
					if (ephemeraledges.length == 0){
						switch (birthedges.length){
						case 0:
							vertexnature = 'cup';
							break;
						case 1:
							vertexnature = 'monotone';
							break;
						case 2:
							vertexnature = 'cap';
							break;
						}
					}
					else {
						//two ephemeral edges means we have a deletable vertex.
						if (ephemeraledges.length == 2){
							vertexnature = 'redundant';
						}
						//is a hook or a crook. crook looks like -\ or /-, hook looks like _/ or \_ 
						switch (birthedges.length){
							case 0:
								vertexnature = 'hook';
								break;
							case 1:
								vertexnature = 'crook';
								break;
						}
					}
					//end of preliminary nature finding
				

					//work out where to throw sweep lines
					//while we're at it, if we pass a cup we make sure the order of the edges in birthedges is in terms of increasing x-direction.
					//returns throwsweeps = 0 if no sweeps, 1 if sweep left, 2 if sweep right, 3 if sweep both.
					//default is to throw no sweeps.
					var throwsweeps = 0;
								
				
				
					switch(vertexnature){
						//caps and cups are different. it's easiest to work out how they are pointing relative to the orientation of the polygon.
					case 'cap':

						if (polygon.localOrientation(priorvertex, vertex, followvertex) != globalorientation){
							throwsweeps = 3;
							birthedges = [birthedges[1], birthedges[0]];
						}				
						break;
					
					case 'cup':
					
						if (polygon.localOrientation(priorvertex, vertex, followvertex) != globalorientation){
							throwsweeps = 3;
						}
						break;
						
					//otherwise it's relatively straightforward.
					case 'monotone':
						//doesn't depend on anything but if it's going up or down, and the global orientation.
					
						if (globalorientation == -1){
							//anticlockwise and flowing up
							if (priorvertex[1] < followvertex[1]){
								throwsweeps = 1;
							}
							//flowing down
							else {
								throwsweeps = 2;
							}
						}
						else {
							//clockwise and flowing up
							if (priorvertex[1] < followvertex[1]){
								throwsweeps = 2;
							}
							//flowing down
							else {
								throwsweeps = 1;
							}
						}
						break;
					
					case 'hook':
						// _/ or \_. essentially we have to be careful with how we throw the sweeps, as we can get duplicates or throw sweeps to edges that haven't yet been initialised.
						// as the vertices at same height are going to be initialised right-left, we can never throw a sweep horizontally left as the edge won't yet be initialised.
						// (we have to throw horizontally right if there is a flat edge right, then.)
						//flat edge is on the left
						if (ephemeraledges[0][0] == vertex){
							console.log('left flat hook')
						}
						//flat edge is on right
						else {
							throwsweeps += 2;
							console.log('right flat hook')
						}
						break;
					case 'crook':
						console.log(vertex);
						//flat edge is on the left
						if (ephemeraledges[0][0] == vertex){
							console.log('left flat crook')
						}
						//flat edge on right
						else {
							throwsweeps +=2;
							console.log('right flat crook')
						}
					

					}
								
					//end of this vertex
					var thisinfo = [vertex, throwsweeps, birthedges, deathedges, ephemeraledges];
					resolutiondata.push(thisinfo);
				}
				return resolutiondata;

			}
			//end of getting resolution data
			
			function vertexPosition(edgelist, peei, pinfinity){
				
				//we find the index in current that the vertex is at.
				//initialises left and right bounds on index
				var l = -1;
				var r = edgelist.length;
				

				
				while (l < r-1){
					//gets midpoint of l and r
					var mid = Math.floor((l+r)/2);

					//tests to see if both on same side
					if (sameCutSide(edgelist[mid], peei, pinfinity) > 0){
						//if they are, the current middle line is to the left of the point.
						l = mid;
						//l is now a line to the left of the point.
					}
					else if (sameCutSide(edgelist[mid], peei, pinfinity) < 0) {
						//otherwise, the current middle line is to the right.
						//or the middle line goes straight through the point.
						r = mid;
						//if the middle line goes through the point, r is now a line going through the point.
						//otherwise it is to the right of the point.
						
					}
					else {
						
						//we've hit the point with the mid-line.
						//we verify whether there's a unique line or we're at the bottom of a cup.
						if (edgelist[mid+1] && sameCutSide(edgelist[mid+1], peei, pinfinity) == 0){
							l = mid;
							r = mid+1;
						}
						else if (edgelist[mid-1] && sameCutSide(edgelist[mid-1], peei, pinfinity) == 0){
							l = mid-1;
							r=mid;
						}
						else {
							//just a unique line in this case.
							l = r = mid;
						}
					}
		
				}
				return [l,r];
			}
			
			function sweepIntersection(vertex, edge){
				console.log('called sweepintersection with vertex'+vertex+'edge'+edge);
				var p = edge[0];
				var q = edge[1];
				var delx = (p[0]-q[0]);
				if (delx == 0){
					return [p[0], vertex[0]];
				}
				var m = (p[1]-q[1])/delx;
				var c = p[1]-m*p[0];
				var y = vertex[1];
				return [(y-c)/m, y];
			}
			
		//determines whether two points are on the same side of a line that is specified by two points.
			//returns positive if on same side.
			//negative if opposite
			//zero if on the line.
			function sameCutSide(line, point1, point2){
				var line1 = line[0];
				var line2 = line[1];
				
				var checker = ((line1[1]-line2[1])*(point1[0]-line1[0])+(line2[0]-line1[0])*(point1[1]-line1[1]))*((line1[1]-line2[1])*(point2[0]-line1[0])+(line2[0]-line1[0])*(point2[1]-line1[1]))
				
				return Math.sign(checker);
				
			}
			
			var trapeziumdecomposition = []
			
			//creates copy. this is shallow copy; entries still point to the same vertices. if you modify a vertex it will modify in both.
			//note this omits the final vertex which is a duplicate of the first.
			
	//		var vertices = polygon.slice(0,polygon.length-1);
			
			//gets all the information for resolving at a given vertex.
			//returns list of elements of form
			// [vertex, sweepdirections, birthedges, deathedges, ephemeraledges]
			// ordered by descending y-coordinate of the vertex.
			var resolutioninfo = getVertexResolutionData(polygon);	
			resolutioninfo.sort(function(a, b){
				
				if (b[0][1]-a[0][1] != 0){
					return b[0][1]-a[0][1];
				}
				//sort by highest to lowest x coord if y coords the same.
				if (b[0][1]-a[0][1] == 0){
					return b[0][0]-a[0][0];
				}
				//return b[0][1]-a[0][1]
			
			});
			
//			console.log(resolutioninfo);
			
			//computes upper bound for x-value.
			var rightbound = this.rightBound() + 1;


			
			//START OF STAGE 2.
			///i'm supposed to store edges as a red-black tree but it's all complicated enough already.
			var currentedges = [];
			//also store previous intersection of an edge that is in currentedges with the sweepline.
			//we need these to actually build the trapeziums.
			var prevsweepintersections = [];
			console.log('new trap');
			console.log('resolution info is');
			console.log(resolutioninfo)
			//start sweeping.
			for (var i = 0; i<resolutioninfo.length; i++){
				
				//recall resolutioninfo is of form [vertex, sweepdirections, birthedges, deathedges, ephemeraledges]
				var currentinfo = resolutioninfo[i];
				var vertex = currentinfo[0];
				var pinfinity =  [rightbound,vertex[1]]
								console.log('current vertex is'+vertex)
				
				var birthedges = currentinfo[2];
				var deathedges = currentinfo[3];
				
				
				//gets the position of the vertex in the edgelist.
				var vertexposition = vertexPosition(currentedges, vertex, pinfinity);
				
				
				//compute the neighbouring edges, indices and previous intersections, if defined.
				var neighbourindices = [,];
				var vertexneighbours = [,];
				//if ephemeral or monotone, these are either side of the ones we find.
				if (vertexposition[0] == vertexposition[1]){
					neighbourindices = [vertexposition[0]-1, vertexposition[1]+1];
				}
				//if it's a cup, the cup edges should be in vertexposition[0] and vertexposition[0]+1
				else if (deathedges.length > 0){
					neighbourindices = [vertexposition[0]-1, vertexposition[1]+1]
					//one or both will be undefined if we are are adjacent to a side of the polygon. (both if we're at a final cup)
				}
				//if it's a cap, the neighbours will be in position vertexposition[0] and vertexpositon[1];
				else if (birthedges.length >0){
					neighbourindices = [vertexposition[0], vertexposition[1]];
				}
				
				
				vertexneighbours = [currentedges[neighbourindices[0]], currentedges[neighbourindices[1]]];
				var previousneighbourintersections = [prevsweepintersections[neighbourindices[0]], prevsweepintersections[neighbourindices[1]]];
								
				//generally this is one trapezium, unless we have a specific type of cup.
				var trapeziums = [];
				
				var ephemeraledges = currentinfo[4];
				
				
				//if no ephemeral edges:
				if (ephemeraledges.length == 0){
					
					// if it is a monotone vertex, we can just modify in place.
					if (vertexposition[0] == vertexposition[1]){
				
						//just change the dying edge for the born edge. poetic.
						currentedges[vertexposition[0]] = birthedges[0];

						//here, we push a new trapezium to trapeziums.
						//initially this contains the current vertex, then the previous swept vertex on the current vertex's edge.
						trapeziums.push([vertex, prevsweepintersections[vertexposition[0]]]);
					
						//now we can update the sweepintersections to signify that this is the most recent sweep-line intersection with this edge.
						prevsweepintersections[vertexposition[0]] = vertex;
					
					}
					
				
					//if it's not monotone, it's either a cap or a cup.
					else {
						//removes a pair of dying edges at a cup
						if (deathedges.length > 0){
						//	console.log('removing dying edges')
						
							// push the previous intersections to trapeziums. in the case where i'm to throw two sweeps, we have two trapeziums.
							if (currentinfo[1] == 3){
							
						
							//initialise them here with the vertex, and two previous sweepintersections of neighbours.
							trapeziums.push([vertex, prevsweepintersections[vertexposition[0]]], [vertex, prevsweepintersections[vertexposition[1]]]);

							}
							//or there is a degenerate cup triangle here. in this case we already know everything!
							else {

								var degentriangle = [vertex, prevsweepintersections[vertexposition[0]], prevsweepintersections[vertexposition[1]]]

								trapeziums.push([degentriangle]);

							}
							//now we kill the edges.
							currentedges.splice(vertexposition[0], 2);
						

						
							//adjust sweep intersections too, to remove entries tracking these edges.
							prevsweepintersections.splice(vertexposition[0], 2);
						}
				
						// adds a pair of birthing edges at a cap.
						if (birthedges.length > 0){
								//inserts the birth edges in at the position of the vertex in the list
								currentedges.splice(vertexposition[1], 0, ...birthedges);
								//inserts the vertex at the same position in the prevsweep list
								var newints = [vertex, vertex];
								prevsweepintersections.splice(vertexposition[1], 0, ...newints);
							
								//just initialise the trapezium
								trapeziums.push([]);
						}
					}
				}
				//if ephemeral
				else {
					console.log('ephemeral');
					currentedges.splice(vertexposition[1], 0, ...birthedges);
					prevsweepintersections.splice(vertexposition[1], 0, ...[vertex]);
					console.log(vertexposition[0]);
					console.log(vertexposition[1]);
					trapeziums.push([]);
				}


				
				//now that the edgelist is updated, we go ahead and work out the sweep intersections we need.
				var intersections = [];
				


//monotone case:
//just build a trapezium.
//cap and cup cases:
//cap: if i throw neither ways then i'm the point of a little mountain. so there's no trapezium to build.
//if i throw both ways, then i'm the point of an external mountain. i need to then set *no* edges of the polygon to the vertex i'm at, but rather to set them to be the two outside edges. then i build the trapezium with this (total) sweep-line as its bottom.
//cup: if i throw neither ways then i'm the bottom of a valley. i build a degenerate trapezium that is a triangle.
// if i throw both then i'm in an external valley. i have two trapeziums which meet at my vertex. 

				var thissweepline = [];
				console.log('current edges');
									console.log(currentedges);
									console.log('prev sweep intersections');
									console.log(prevsweepintersections);
									console.log('current trap')
									console.log(trapeziums);

				switch(currentinfo[1]){					
				case 1:
					//left sweep
					intersections = [sweepIntersection(vertex, vertexneighbours[0])];
					
					//add the neighbour's previous intersection to the trapezium
					trapeziums[0].push(prevsweepintersections[neighbourindices[0]]);
					
					//update the sweep intersections of the neighbouring line.
					prevsweepintersections[neighbourindices[0]] = intersections[0];
					
					//add the new intersection to the trapezium
					trapeziums[0].push(prevsweepintersections[neighbourindices[0]]);

					drawPoint(intersections[0]);
					[vertex, intersections[0]];

					break;
				case 2:
					//right sweep
					intersections = [sweepIntersection(vertex, vertexneighbours[1])];
			
					//add the neighbour's previous intersection to the trapezium
					trapeziums[0].push(prevsweepintersections[neighbourindices[1]]);
			
					//update the sweep intersections of the neighbouring line.
					prevsweepintersections[neighbourindices[1]] = intersections[0];
			
					//add the new intersection to the trapezium
					trapeziums[0].push(prevsweepintersections[neighbourindices[1]]);
			
					drawPoint(intersections[0]);
					[vertex, intersections[0]];
					//makePLPath([vertex, intersections[0],vertex]);
					break;
				case 3:


					intersections = [sweepIntersection(vertex, vertexneighbours[0]), sweepIntersection(vertex, vertexneighbours[1])];

					//if i'm a cap					
					if (birthedges.length == 2){
				//because we inserted the new edges into the edgelist already, the indexing is a bit confused.
				//what was in neighbourindex[1] is now in neighbourindex[1]+2.
						trapeziums[0].push(intersections[1], prevsweepintersections[neighbourindices[1]+2],  prevsweepintersections[neighbourindices[0]], intersections[0]);

						//updates the sweep intersections
						//same indexing considerations as above.
						prevsweepintersections[neighbourindices[0]] = intersections[0];
						prevsweepintersections[neighbourindices[1]+2] = intersections[1];

					}
					//i must be a cup otherwise
					//here we have two trapeziums. they already contain the vertex plus the other vertex on its line.
					else {
						trapeziums[0].push(previousneighbourintersections[0], intersections[0]);
						trapeziums[1].push(previousneighbourintersections[1], intersections[1]);
						
						//updates the sweep intersections

						//we killed the cup edges so we need slighty different indexing.

						prevsweepintersections[neighbourindices[0]] = intersections[0];
						prevsweepintersections[neighbourindices[1]-2] = intersections[1];

					}

										
					drawPoint(intersections[0]);
					drawPoint(intersections[1]);
					thissweepline = intersections;
					break;
				}

				
				
				
	
				
				
			//we're done with this vertex (at last)!
//because i shouldn't have initialised the trapezium in case it's a funny cap, we have to test this.... sigh
				console.log(trapeziums);
				if (trapeziums.length!= 0 && trapeziums[0].length != 0){
					var notraps = trapeziums.length;
					for (var j=0; j<notraps; j++){
						var actualtrapezium = new Polyline(this.name+'trap'+j, trapeziums[j], true);
						trapeziumdecomposition.push(actualtrapezium);	
					}	
						
				}
			//end of vertex. loop begins again.s
			}
		this.trapeziumdecomposition = trapeziumdecomposition;	
		}
		
		showTrapeziumDecomposition(){
			if (!this.trapeziumdecomposition){
				this.findTrapeziumDecomposition();				
			}
			if (this.isclosed){
				var notraps = this.trapeziumdecomposition.length;
				for (var i=0; i<notraps; i++){
					this.trapeziumdecomposition[i].draw();				
				}
				
			}

		}
		
		
		//decomposes a polyline into a number of monotone sections.
		//if it isn't generic, i.e. we have 'horizontal' sections, it treats the horizontal pieces as sections.
		monotoneDecomposition(){
			var monotonepolylines = [];
			var noverts = this.vertices.length;
			var currentsection = [this.vertices[0]];
			
			function moveDirection(p,q){
				if (p[1]<q[1]){
					return 1;
				}
				else if (p[1]>q[1]){
					return -1;
				}
				else {
					return 0;
				}
			}
			
			var movedir = moveDirection(this.vertices[0], this.vertices[1]);
			
			for (var i=1; i<noverts-1; i++){

				var currentvertex = this.vertices[i];
				if (moveDirection(this.vertices[i-1], currentvertex) == movedir){
					currentsection.push(currentvertex);
				}
				else {
					monotonepolylines.push(currentsection);
					movedir = moveDirection(this.vertices[i-1], currentvertex);
					currentsection = [this.vertices[i-1], currentvertex];
				}
			}
			currentsection.push(this.vertices[noverts-1]);
			monotonepolylines.push(currentsection);
			return monotonepolylines;
		}
		
		
		
		
		
	 }
	 
	
//END OF POLYLINE	 
	 
	function crossProduct(u, v){
		return [u[1]*v[2] - u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0]];
	}
	 
	function drawLabel(point, text){
		//optional: label the point
		label = document.createElementNS(NS, "text");
		label.setAttribute("x", point[0]);
		label.setAttribute("y", point[1]);
		label.innerHTML = text;
		label.setAttribute("font-size", "6pt");
		page.appendChild(label);
	}
	
	 
	 var paths = [];
	 var polylines = [];
	 var newestpath = undefined;
	 
	 
	 function clickedCoords(){
		 var page = document.getElementById("page");
    	 var dim = page.getBoundingClientRect();
    	 var x = event.clientX - dim.left;
		 var y = event.clientY - dim.top;
		 return [x,y];
	 }
	 function coordString(list){
		 var string = list[0].toString();
		 var numbercoords = list.length;
		 for (var i = 1; i < list.length; i++) {
			 string += (','+list[i].toString());
		 }
		 return string;
	 }
	 
	 function dist(coord1, coord2){
		 return Math.sqrt((coord1[0]-coord2[0])*(coord1[0]-coord2[0])+(coord1[1]-coord2[1])*(coord1[1]-coord2[1]))
	 }
	 
	 function isNear(a, b){
		 return (dist(a,b) < 40);
	 }
	 
	function drawPoint(point){
		//how big do you want the point?
		radius = 2;
		
		thepoint = document.createElementNS(NS, "circle");
		thepoint.setAttribute("cx", point[0]);
		thepoint.setAttribute("cy", point[1]);
		thepoint.setAttribute("r", radius);
		
		page.appendChild(thepoint);
		

	}
	 
	 
	 function beginUserCurve(){  		
 			var page = document.getElementById("page");
 			var thepath = document.createElementNS(NS, "path");
			
			curvename = "path"+(paths.length+1);
						
 			thepath.setAttribute("class", "usercurve");
			thepath.setAttribute("id", curvename);
			
		var currentpos = clickedCoords();
			
 			//makes a correct 'd' string out of the nodeslist for passing to the path. start by initialising start point.
 			var datastring = "M "+coordString(currentpos);
			
			
			thepath.setAttribute("d", datastring)
			
			
			newestpath = new UserPath(curvename, [currentpos], false, thepath);
			
			paths.push(newestpath);
			newestpath.draw();
			
	 }
	 
	 function continueUserCurve(){
		var page = document.getElementById("page");
		
		var currentpos = clickedCoords();
		newestpath.vertices.push(currentpos);
		newestpath.svgelement.setAttribute("d", newestpath.svgelement.getAttribute("d")+' L '+ coordString(currentpos) );
	 }
	 
	 function finishUserCurve(){
 		var page = document.getElementById("page");

		 if (isNear(newestpath.vertices[0], newestpath.vertices[newestpath.vertices.length-1])){
			// newestpath.vertices[0] = newestpath.vertices[newestpath.vertices.length-1];
			newestpath.isclosed = true;
			 newestpath.svgelement.setAttribute("d", newestpath.svgelement.getAttribute("d")+' Z ');
		 }
		 
		//gets the polyline approximation and computes orientation. 
		 
		polylined = newestpath.toPolyline()
		polylined.orientation = polylined.findOrientation();
		
		//if it's not anticlockwise, then reverse the orientation of the vertex list.
		if (polylined.orientation == -1){
			polylined.vertices.reverse()
		}
		
		polylines.push(polylined);
		
		
		//depending on current showing settings, draws as polygon or as smoothed. (or both!)
		if (showsmootharcs){
			polylined.drawSmooth();
		}
		if (showpolylines){
			polylined.draw();
		}
		if (showorientations){
			polylined.showOrientation();
		}
		if (showtrapeziums){
			polylined.showTrapeziumDecomposition();
		}
		if (labelvertices){
			polylined.labelVertices();
		}
		

		newestpath.undraw();
		newestpath = undefined;

		 
	 }
	 
	 function startDrawing(){
		 nowdrawing = true;
		 beginUserCurve();
	 }
	 
	 var nowdrawing = false;
	 
	 function continueDrawing(){
		 if (nowdrawing){
		 continueUserCurve()
	 	}
	 }
	 
	 function stopDrawing(){
		 nowdrawing = false;
		 finishUserCurve();
	 }
	 
	 function drawPolylines(){
		 showpolylines = true;
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].draw();
		 }
	 }
	 
	 function hidePolylines(){
		 showpolylines = false;
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].hide();
		 }
	 }
	 
	 function drawSmoothArcs(){
		 showsmootharcs = true;
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].drawSmooth();
		 }
	 }
	 
	 function hideSmoothArcs(){
		 showsmootharcs = false;
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].hideSmooth();
		 }
	 }
	 
	 function showOrientations(){
		 showorientations = true;
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].showOrientation();
		 }
	 }
	 
	 function hideOrientations(){
		 showorientations = false;
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].hideOrientation();
		 }
	 }
	 
	 function showTrapeziumDecompositions(){
		 showtrapeziumdecompositions = true;
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].showTrapeziumDecomposition();
		 }
	 }
	 
	 function hideTrapeziumDecompositions(){
		 showtrapeziumdecompositions = false;
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].hideTrapeziumDecomposition();
		 }
	 }
	 
	 function labelAllVertices(){
		 for (var i=0; i< polylines.length; i++){
			 polylines[i].labelVertices(); 
		 }
	 }
	 
	 function getMonotoneDecompositions(){
		 for (var i = 0; i < polylines.length; i++){
			 polylines[i].monotoneDecomposition();
		 }
	 }
	 
	</script>
	<style>
		
		/*general*/
		/*diagram canvas*/
		#page {
			/*background-color:#81DAF5;*/
			height: calc(100% - 1.5rem);
			border-top: 1px black solid;
		}
		

		
		body {
			margin: 0 0 0 0;
			background-color:#81DAF5;
		}
		
		/* navigation bar list styles*/
		a {
		  text-decoration: none;
		  color: black;
		}
		
		nav {
			font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
			    "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans",
			    "Droid Sans", "Helvetica Neue", sans-serif;
				font-size: 11pt;				
		}
		
		nav ul {
		    list-style: none;
		    margin: 0;
		    padding: 0;
			background-color: rgba(255, 255, 255, 0.4);
			 border-radius: 0 0 3px 3px;
		}
		
		nav ul li:hover{
			background-color: rgba(28, 102, 213, 1);
		}
		
		nav ul li {
			height: 1.4rem;
			padding: 0.1rem 0.5rem 0rem 0.5rem;
			display: block;
			float: left;
			position: relative;

  		  
			
		}

		
		nav ul li > ul {
			visibility: hidden;
			display: block;

  		  position: absolute;

  		  margin-top: 0.4rem;
  		  left: 0;
		  margin-left: 0rem;
		  padding: 0;
/*			width: 100%;*/
		}
		
		nav ul li:hover > ul {
			visibility: visible;
			display: block;
/*			width: 100%;*/
		}
		
		nav ul li ul li{
			position: relative;
			width: 100%;
			padding: 0;
		}
		
		
		nav ul li a {
			white-space:nowrap;
			
		}
		nav ul li ul li a{
			padding-left: 1rem;
			padding-right: 1rem;
		}
		
		/*second level*/
		nav ul li ul li > ul{
			position: relative;
			left: 100%;
			padding: 0;
			top: -1.45rem;
			
		}
		
		
		nav ul li ul li ul li{
		background-color: rgba(255, 255, 255, 0.4);	

		}
		
		a.submenu::after {
			
			    content: "\25b6";
			    display:inline-block;
				float: right;
				padding-right: 0.5em;
			
		}
		
		
		
		
		
		a.fullscreenopen, a.fullscreenclose{
			
			float: right;
			margin-right: 0.2rem;

		}
		a.fullscreenopen {
			display: block;
		}
		a.fullscreenclose{
			display: none;
		}
		:-webkit-full-screen a.fullscreenopen {
		  display: none;
		}

		:-moz-full-screen a.fullscreenopen {
		  display: none;
		}

		:-ms-fullscreen a.fullscreenopen {
		  display: none;
		}

		:fullscreen a.fullscreenopen {
		  display: none;
		}
		
		:-webkit-full-screen a.fullscreenclose {
		  display: block;
		}

		:-moz-full-screen a.fullscreenclose {
		  display: block;
		}

		:-ms-fullscreen a.fullscreenclose {
		  display: block;
		}

		:fullscreen a.fullscreenclose {
		  display: block;
		}
             
		.usercurve {
			stroke: black;
			fill: none;
		}
		.alphaArc {
			stroke: red;
			fill: none;
		}
		
		.navbarrest {
			background-color: rgba(255, 255, 255, 0.4);
			display:block;
			width: 100%;
			height:1.5rem;
		}
		
		
	</style>
</head>
<body>
<!-- start menu -->
<nav role="navigation">
  <ul>
    <li><a href="#">File</a>
	    <!--<ul class="dropdown" aria-label="submenu">
	      <li><a href="#"> New diagram</a></li>
	      <li><a href="#"> Export to SVG </a></li>
	      <li><a href="#"> Save diagram</a></li>
	    </ul>-->
	</li>
    <li><a href="#" aria-haspopup="true">Diagram</a>
     <!-- <ul class="dropdown" aria-label="submenu">
        <li><a href="#">New curve</a></li>
        <li><a href="#">New polygon</a></li>
        <li><a href="#">New handle</a></li>
      </ul>-->
    </li>
    <li><a href="#">Computation</a></li>
    	<!--<ul class="dropdown" aria-label="submenu">
       		<li><a href="#" onclick="getMonotoneDecompositions()">Monotone Decompositions</a></li>       	 	
     	</ul>-->
	<li><a href="#">View</a>
		<ul>
			<li><a class="submenu" href="#">Polylines</a>
				<ul>
					<li><a href="#" onclick="drawPolylines()">Show polylines</a></li>
					<li><a href="#" onclick="hidePolylines()">Hide polylines</a></li>
					<li><a href="#" onclick="labelAllVertices()">Label vertices</a></li>
				</ul>
			</li>
			<li><a class="submenu" href="#">Arcs</a>
				<ul>
					<li><a href="#" onclick="drawSmoothArcs()">Show arcs</a></li>
					<li><a href="#" onclick="hideSmoothArcs()">Hide arcs</a></li>
				</ul>
			</li>
			<li><a href="#" onclick="showOrientations()">Show orientations</a>
			</li>
			<li><a class="submenu" href="#">Trapeziums</a>
				<ul>
					<li><a href="#" onclick="showTrapeziumDecompositions()">Show trapezium decompositions</a></li>
					<li><a href="#" onclick="hideTrapeziumDecompositions()">Hide trapezium decompositions</a></li>
				</ul>
			</li>
		</ul>
	</li>
  </ul>
</nav>
<div class="navbarrest"><a href='#' class="fullscreenopen" onClick="openFullscreen()" id="openfullscreenbutton">&#8862;</a>
<a href='#' class="fullscreenclose" onClick="closeFullscreen()" id="fullscreenbutton">&#8863;</a></div>
		<svg width="100%" id="page" onmousedown = "startDrawing()" onmousemove = continueDrawing() onmouseup=stopDrawing()>
			
		</svg>
</body>
</html>